{"version":3,"sources":["../src/index.ts","../src/libs/registry.ts","../src/decorators/register.ts","../src/functions/expose-children.ts","../src/libs/types.ts","../src/libs/service-refs.ts","../src/functions/resolve.ts","../src/functions/resolve-context.ts","../src/functions/resolve-instance.ts","../src/plugin/vuedi.plugin.ts"],"sourcesContent":["export * from './decorators/register';\r\nexport * from './functions/expose-children';\r\nexport * from './functions/resolve';\r\nexport * from './functions/resolve-context';\r\nexport * from './functions/resolve-instance';\r\nexport * from './libs/registry';\r\nexport * from './libs/service-refs';\r\nexport * from './libs/types';\r\nexport * from './plugin/vuedi.plugin';\r\n\r\n","import type { ServiceConstructor } from './types';\r\n\r\nexport const SERVICE_INTERNAL_METADATA = Symbol('VUEDI_SERVICE_METADATA');\r\nexport const serviceRegistry = new Map<symbol, any>();\r\nexport const serviceRefView = new WeakMap<InstanceType<ServiceConstructor>, any>();\r\n","import { SERVICE_INTERNAL_METADATA } from '../libs/registry';\r\nimport type { ServiceConstructor } from '../libs/types';\r\n\r\nexport function Register() {\r\n  return function <C extends ServiceConstructor>(constructor: C) {\r\n    // Its Already Registered\r\n    if ((constructor as any)[SERVICE_INTERNAL_METADATA]?.token) {\r\n      return constructor;\r\n    }\r\n\r\n    const token = Symbol(`vuedi:service:${constructor.name || 'Anonymous'}`);\r\n    (constructor as any)[SERVICE_INTERNAL_METADATA] = { token };\r\n    return constructor;\r\n  };\r\n}\r\n","import { getCurrentInstance, onScopeDispose, provide } from 'vue';\r\nimport { ImplementsDispose, type ServiceConstructor, type ServiceWithDispose } from '../libs/types';\r\nimport { getServiceRef } from '../libs/service-refs';\r\nimport { serviceRefView } from '../libs/registry';\r\n\r\nexport function exposeToChildren<T extends ServiceConstructor>(classOrInstance: T | InstanceType<T>): void {\r\n  let instance: any;\r\n  let ownsInstance = false;\r\n\r\n  if (typeof classOrInstance === 'function') {\r\n    instance = new (classOrInstance as T)();\r\n    ownsInstance = true;\r\n  } else {\r\n    instance = classOrInstance;\r\n  }\r\n\r\n  const refView = getServiceRef(instance) as InstanceType<T>;\r\n\r\n  provide(instance.constructor, refView);\r\n\r\n  if (ownsInstance) {\r\n    const componentInstance = getCurrentInstance();\r\n\r\n    if (componentInstance) {\r\n      onScopeDispose(() => {\r\n        if (ImplementsDispose(instance)) {\r\n          try {\r\n            (instance as ServiceWithDispose<T>).dispose();\r\n          } catch (error) {\r\n            console.error('Error in context service onUnmounted:', error);\r\n          }\r\n        }\r\n\r\n        if (serviceRefView.has(instance)) {\r\n          serviceRefView.delete(instance);\r\n        }\r\n        instance = null;\r\n      });\r\n    }\r\n  }\r\n}\r\n","export type ServiceConstructor<T extends object = object> = new () => T;\r\n\r\nexport interface Disposable {\r\n  dispose(): void;\r\n}\r\n\r\nexport function ImplementsDispose(instance: unknown) {\r\n  return typeof (instance as any).dispose === 'function';\r\n}\r\n\r\nexport type ServiceWithDispose<T> = T & {\r\n  dispose(): void;\r\n};\r\n\r\nexport type ServiceMetadata = {\r\n  token: symbol;\r\n};\r\n","import { serviceRefView } from './registry';\r\nimport { computed, isReactive, isRef, toRaw, toRef } from 'vue';\r\nimport type { ServiceConstructor } from './types';\r\n\r\nfunction serviceToRefs<T extends InstanceType<ServiceConstructor>>(service: T) {\r\n  const rawService = toRaw(service);\r\n  const refs: any = {};\r\n\r\n  /// loop through all object properties\r\n  for (const key in service) {\r\n    const value = rawService[key];\r\n\r\n    if ((value as any).effect) {\r\n      refs[key] = computed({\r\n        get: () => service[key],\r\n        set: newValue => {\r\n          service[key] = newValue;\r\n        },\r\n      });\r\n    } else if (isRef(value) || isReactive(value)) {\r\n      refs[key] = toRef(service, key);\r\n    }\r\n  }\r\n  return refs;\r\n}\r\n\r\nexport function getServiceRef<T extends InstanceType<ServiceConstructor>>(instance: T): T {\r\n  const cached = serviceRefView.get(instance);\r\n  if (cached) return cached;\r\n  const refs = serviceToRefs(instance);\r\n  serviceRefView.set(instance, refs);\r\n  return refs;\r\n}\r\n","import { SERVICE_INTERNAL_METADATA, serviceRegistry } from '../libs/registry';\r\nimport { getServiceRef } from '../libs/service-refs';\r\nimport { type ServiceConstructor, type ServiceMetadata } from '../libs/types';\r\n\r\n/// this will only be used fro global services\r\nexport function resolve<T extends ServiceConstructor>(serviceClass: T): InstanceType<T> {\r\n  const config = (serviceClass as any)[SERVICE_INTERNAL_METADATA] as ServiceMetadata;\r\n\r\n  if (!config) {\r\n    throw new Error('[VUE DI]: No Config Meta date Found, Make Sure To Use @Register() Service Classes');\r\n  }\r\n\r\n  const serviceToken = config.token;\r\n  let instance: InstanceType<T>;\r\n\r\n  if (serviceRegistry.has(serviceToken)) {\r\n    instance = serviceRegistry.get(serviceToken) as InstanceType<T>;\r\n  } else {\r\n    instance = new serviceClass() as InstanceType<T>;\r\n    serviceRegistry.set(serviceToken, instance);\r\n  }\r\n\r\n  return getServiceRef(instance);\r\n}\r\n","import { inject } from 'vue';\r\nimport type { ServiceConstructor } from '../libs/types';\r\n\r\nexport function resolveFromContext<T extends ServiceConstructor>(serviceClass: T): InstanceType<T> | undefined {\r\n  return inject<InstanceType<T>>(serviceClass.name);\r\n}\r\n","import { getCurrentInstance, onScopeDispose } from 'vue';\r\nimport { ImplementsDispose, type ServiceConstructor, type ServiceWithDispose } from '../libs/types';\r\nimport { serviceRefView } from '../libs/registry';\r\nimport { getServiceRef } from '../libs/service-refs';\r\n\r\nexport function resolveInstance<T extends ServiceConstructor>(serviceClass: T): InstanceType<T> {\r\n\r\n  let instance = new serviceClass();\r\n  const componentInstance = getCurrentInstance();\r\n\r\n  if (componentInstance) {\r\n\r\n    onScopeDispose(() => {\r\n      if (ImplementsDispose(instance)) {\r\n        try {\r\n          (instance as ServiceWithDispose<typeof instance>).dispose();\r\n        } catch (error) {\r\n          console.error('Error in scope dispose:', error);\r\n        }\r\n      }\r\n\r\n      if (serviceRefView.has(instance as object)) {\r\n        serviceRefView.delete(instance as object);\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  return getServiceRef(instance) as InstanceType<T>;\r\n}\r\n","import type { FunctionPlugin } from 'vue';\r\nimport { serviceRegistry } from '../libs/registry';\r\nimport type { ServiceConstructor } from '../libs/types';\r\n\r\ntype VueDIOptions = {\r\n  services: ServiceConstructor[];\r\n};\r\n\r\nexport const vuediPlugin: FunctionPlugin<[Partial<VueDIOptions>?]> = (_app, options?: Partial<VueDIOptions>) => {\r\n  ///Eagerly create instances\r\n  if (options?.services) {\r\n    options.services.forEach(item => {\r\n      const serviceInstance = serviceRegistry.has(item);\r\n      if (!serviceInstance) {\r\n        serviceRegistry.set(item, new item());\r\n      }\r\n    });\r\n  }\r\n};\r\n"],"mappings":"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","names":["import_vue","import_vue","import_vue"]}